---
layout: post
author: Jacob Garby
title: Presenting My Paper at Euro-Par 2025
---

Last week I was in Dresden for [Euro-Par 2025](https://2025.euro-par.org/)! I went to present [my paper](https://link.springer.com/chapter/10.1007/978-3-031-99857-7_17) about speeding up neural network training with a new kind of parallel thread synchronisation scheme. It was the first time doing that since starting my PhD back in September 2023, so I wasn't quite sure what to expect, but it was a really fun event. I even managed to sneakily record my own presentation (see below!)

<center>
<iframe width="90%" height="400px" src="https://www.youtube.com/embed/RnzR7FxzWx8?si=j6N3mjfjr-Imf2ru&amp;start=19" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</center>

## The Paper

<a href="/assets/pdf/int_async.pdf"><svg class="bi bi-filetype-pdf" fill="currentColor" height="64" viewBox="0 0 16 16" width="64" xmlns="http://www.w3.org/2000/svg"><path d="M14 4.5V14a2 2 0 0 1-2 2h-1v-1h1a1 1 0 0 0 1-1V4.5h-2A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v9H2V2a2 2 0 0 1 2-2h5.5L14 4.5ZM1.6 11.85H0v3.999h.791v-1.342h.803c.287 0 .531-.057.732-.173.203-.117.358-.275.463-.474a1.42 1.42 0 0 0 .161-.677c0-.25-.053-.476-.158-.677a1.176 1.176 0 0 0-.46-.477c-.2-.12-.443-.179-.732-.179Zm.545 1.333a.795.795 0 0 1-.085.38.574.574 0 0 1-.238.241.794.794 0 0 1-.375.082H.788V12.48h.66c.218 0 .389.06.512.181.123.122.185.296.185.522Zm1.217-1.333v3.999h1.46c.401 0 .734-.08.998-.237a1.45 1.45 0 0 0 .595-.689c.13-.3.196-.662.196-1.084 0-.42-.065-.778-.196-1.075a1.426 1.426 0 0 0-.589-.68c-.264-.156-.599-.234-1.005-.234H3.362Zm.791.645h.563c.248 0 .45.05.609.152a.89.89 0 0 1 .354.454c.079.201.118.452.118.753a2.3 2.3 0 0 1-.068.592 1.14 1.14 0 0 1-.196.422.8.8 0 0 1-.334.252 1.298 1.298 0 0 1-.483.082h-.563v-2.707Zm3.743 1.763v1.591h-.79V11.85h2.548v.653H7.896v1.117h1.606v.638H7.896Z" fill-rule="evenodd"/></svg></a>

The paper I presented at Euro-Par was titled "Interval-Asynchrony: Delimited Intervals of Localised Asynchrony for Fast Parallel SGD". It's the first paper I managed to write and get published during my PhD (so far!)

Watch the 20 minute presentation -- or even better, read the paper -- for more details, but here's an overview (simplified, but should still get the point across). Basically, the problem is that we wanted to use the stochastic gradient descent algorithm (SGD) to train a neural network, which in our case is being used for image classification. If you want to speed up this algorithm, you can run it _in parallel_, which just means that you split up the work between a number of workers, which in our case are CPU threads.

The SGD algorithm consists of a number of iterations, and each iteration depends on the result of the previous one. At least, it does if you want it to be completely accurate. Then, the natural way to _parallelise_ this process is to split the work of each iteration across all your threads, wait for them all to finish their piece, and then combine those results together somehow. Don't worry about the details, other than what I've already explained.

So, this works, but some threads are inevitably at least a _tiny_ bit faster than some others, and so they must spend some time doing nothing while waiting for slower ones to finish. This discrepancy adds up when you use hundreds of threads, and significantly limits the speed at which you can train your neural network.

The other side of the spectrum is _asynchronous_ execution, where you basically just let all the threads run iterations independently, with no synchronisation. They all see the same neural network parameters in memory, and can just update them whenever they want. It's really fast in terms of iterations per second, but significantly less _accurate_ than synchronous execution, so maybe more iterations are needed to train the model.

We (and by we I mean my PhD supervisor Philippas Tsigas and I) thought that this trade-off was interesting, and designed a new type of execution scheme which has a parameter to determine "how asynchronous" you want it to be. This is really useful, because actually it turns out that as you get closer to convergence, you want more accurate updates, and so you can just change this parameter over time!

In terms of _how_ exactly the amount of asynchrony is enforced: the idea is that we divide the whole execution into a series of "asynchronous intervals". Threads run normal asynchronous execution during an interval, but any iterations that overlap two intervals are just ignored, i.e. not used to update the model. An interval ends when a certain number -- that parameter that I mentioned a minute ago -- of iterations have been completed during it. The point is that we can bound the inaccuracy by keeping this interval small, or we can widen it and speed up the throughput by rejecting fewer steps. Again, please look at the paper for proper details.

Anyway, it turns out that this is a pretty nice way of adjusting the amount of asynchrony, which is useful when paired with a clever way of setting that interval size parameter (which we also did in the paper!)

## The Conference

As I mentioned, it was my first proper conference, so I didn't really know what to expect. I was quite looking forward to presenting my paper, and so I spent a couple of the evenings after the conference practicing it a bit. Weirdly -- and this seems to happen in general -- the more I rehearsed it, the more I forget what to say while rehearsing, but it always seems to be the case that once I actually go to present it for real it goes fine, more or less.

The conference itself was really well organised, and I met some really nice people there. In fact, I didn't expect I would manage _that_ much networking and socialising -- it's not something I do very much -- but even on the first day (which was workshops rather than the main conference) I met a couple of nice people who were also going to be presenting their work. I think the fact that Euro-Par's scope is quite broad (parallel programming of all kinds, really) made it a lot more interesting: if every presentation was in the same niche as mine, then it might get a little boring? But the theme at least meant I had some kind of understanding of the other works, at some level.

Hopefully I'll get another paper accepted there in the next few years so I can go back :)
